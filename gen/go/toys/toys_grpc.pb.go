// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.7
// source: toys/toys.proto

package toys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Toys_CreateToy_FullMethodName       = "/toys.Toys/CreateToy"
	Toys_DeleteToy_FullMethodName       = "/toys.Toys/DeleteToy"
	Toys_ChangeToy_FullMethodName       = "/toys.Toys/ChangeToy"
	Toys_GetToy_FullMethodName          = "/toys.Toys/GetToy"
	Toys_ListToy_FullMethodName         = "/toys.Toys/ListToy"
	Toys_ListRecommended_FullMethodName = "/toys.Toys/ListRecommended"
)

// ToysClient is the client API for Toys service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ToysClient interface {
	CreateToy(ctx context.Context, in *CreateToyRequest, opts ...grpc.CallOption) (*CreateToyResponse, error)
	DeleteToy(ctx context.Context, in *DeleteToyRequest, opts ...grpc.CallOption) (*DeleteToyResponse, error)
	ChangeToy(ctx context.Context, in *ChangeToyRequest, opts ...grpc.CallOption) (*ChangeToyResponse, error)
	GetToy(ctx context.Context, in *GetToyRequest, opts ...grpc.CallOption) (*GetToyResponse, error)
	ListToy(ctx context.Context, in *ListToyRequest, opts ...grpc.CallOption) (*ListToyResponse, error)
	ListRecommended(ctx context.Context, in *ListRecommendedRequest, opts ...grpc.CallOption) (*ListRecommendedResponse, error)
}

type toysClient struct {
	cc grpc.ClientConnInterface
}

func NewToysClient(cc grpc.ClientConnInterface) ToysClient {
	return &toysClient{cc}
}

func (c *toysClient) CreateToy(ctx context.Context, in *CreateToyRequest, opts ...grpc.CallOption) (*CreateToyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateToyResponse)
	err := c.cc.Invoke(ctx, Toys_CreateToy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toysClient) DeleteToy(ctx context.Context, in *DeleteToyRequest, opts ...grpc.CallOption) (*DeleteToyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteToyResponse)
	err := c.cc.Invoke(ctx, Toys_DeleteToy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toysClient) ChangeToy(ctx context.Context, in *ChangeToyRequest, opts ...grpc.CallOption) (*ChangeToyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeToyResponse)
	err := c.cc.Invoke(ctx, Toys_ChangeToy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toysClient) GetToy(ctx context.Context, in *GetToyRequest, opts ...grpc.CallOption) (*GetToyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetToyResponse)
	err := c.cc.Invoke(ctx, Toys_GetToy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toysClient) ListToy(ctx context.Context, in *ListToyRequest, opts ...grpc.CallOption) (*ListToyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToyResponse)
	err := c.cc.Invoke(ctx, Toys_ListToy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toysClient) ListRecommended(ctx context.Context, in *ListRecommendedRequest, opts ...grpc.CallOption) (*ListRecommendedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRecommendedResponse)
	err := c.cc.Invoke(ctx, Toys_ListRecommended_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ToysServer is the server API for Toys service.
// All implementations must embed UnimplementedToysServer
// for forward compatibility.
type ToysServer interface {
	CreateToy(context.Context, *CreateToyRequest) (*CreateToyResponse, error)
	DeleteToy(context.Context, *DeleteToyRequest) (*DeleteToyResponse, error)
	ChangeToy(context.Context, *ChangeToyRequest) (*ChangeToyResponse, error)
	GetToy(context.Context, *GetToyRequest) (*GetToyResponse, error)
	ListToy(context.Context, *ListToyRequest) (*ListToyResponse, error)
	ListRecommended(context.Context, *ListRecommendedRequest) (*ListRecommendedResponse, error)
	mustEmbedUnimplementedToysServer()
}

// UnimplementedToysServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedToysServer struct{}

func (UnimplementedToysServer) CreateToy(context.Context, *CreateToyRequest) (*CreateToyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateToy not implemented")
}
func (UnimplementedToysServer) DeleteToy(context.Context, *DeleteToyRequest) (*DeleteToyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteToy not implemented")
}
func (UnimplementedToysServer) ChangeToy(context.Context, *ChangeToyRequest) (*ChangeToyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeToy not implemented")
}
func (UnimplementedToysServer) GetToy(context.Context, *GetToyRequest) (*GetToyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToy not implemented")
}
func (UnimplementedToysServer) ListToy(context.Context, *ListToyRequest) (*ListToyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListToy not implemented")
}
func (UnimplementedToysServer) ListRecommended(context.Context, *ListRecommendedRequest) (*ListRecommendedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRecommended not implemented")
}
func (UnimplementedToysServer) mustEmbedUnimplementedToysServer() {}
func (UnimplementedToysServer) testEmbeddedByValue()              {}

// UnsafeToysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ToysServer will
// result in compilation errors.
type UnsafeToysServer interface {
	mustEmbedUnimplementedToysServer()
}

func RegisterToysServer(s grpc.ServiceRegistrar, srv ToysServer) {
	// If the following call pancis, it indicates UnimplementedToysServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Toys_ServiceDesc, srv)
}

func _Toys_CreateToy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateToyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToysServer).CreateToy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Toys_CreateToy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToysServer).CreateToy(ctx, req.(*CreateToyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Toys_DeleteToy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteToyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToysServer).DeleteToy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Toys_DeleteToy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToysServer).DeleteToy(ctx, req.(*DeleteToyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Toys_ChangeToy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeToyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToysServer).ChangeToy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Toys_ChangeToy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToysServer).ChangeToy(ctx, req.(*ChangeToyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Toys_GetToy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetToyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToysServer).GetToy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Toys_GetToy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToysServer).GetToy(ctx, req.(*GetToyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Toys_ListToy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToysServer).ListToy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Toys_ListToy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToysServer).ListToy(ctx, req.(*ListToyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Toys_ListRecommended_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRecommendedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToysServer).ListRecommended(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Toys_ListRecommended_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToysServer).ListRecommended(ctx, req.(*ListRecommendedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Toys_ServiceDesc is the grpc.ServiceDesc for Toys service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Toys_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "toys.Toys",
	HandlerType: (*ToysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateToy",
			Handler:    _Toys_CreateToy_Handler,
		},
		{
			MethodName: "DeleteToy",
			Handler:    _Toys_DeleteToy_Handler,
		},
		{
			MethodName: "ChangeToy",
			Handler:    _Toys_ChangeToy_Handler,
		},
		{
			MethodName: "GetToy",
			Handler:    _Toys_GetToy_Handler,
		},
		{
			MethodName: "ListToy",
			Handler:    _Toys_ListToy_Handler,
		},
		{
			MethodName: "ListRecommended",
			Handler:    _Toys_ListRecommended_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "toys/toys.proto",
}
